# Оглавление
* [1 Вступление](#1)
* [2 Именование](#2)
* [2.1 Файлы классов и пакеты](#2.1)
* [2.2 Файлы ресурсов](#2.2)
* [2.3  Aйди элементов в layout файлах](#2.3)
* [2.4 Именование ресурсов](#2.4)
* [2.5 Именование строк](#2.5) 
* [2.6 Drawable файлы](#2.6) 
* [2.7 Layout файлы](#2.7) 
* [2.8 Menu файлы](#2.8) 
* [3 Code guidelines](#3) 
* [3.1 Общие рекомендации по стилю кода](#3.1) 
* [3.2 Annotations](#3.2) 
* [3.3 Порядок методов в классе](#3.3) 
* [4 Общие рекомендации](#4) 
* [5 Настройка билдов](#5) 
* [5.1 Типы билдов и их настройка](#5.1) 
* [5.2 Общие положения по настройке билдов](#5.2) 
* [5.3 Автоматическая выкладка билдов в Google Play](#5.3) 
* [6 Git](#6)
* [7 Именование версий](#7) 
* [8 Раздел для Kotlin](#8) 
* [9 Актуальные библиотеки](#9) 
* [10 Задачи “Просто верстаем, пока нет API”](#10) 
* [11 Векторная графика и Zeplin](android-zeplin.md)
* [12 Рекомендации по архитектуре](#12)
* [13  Рекомендации по внешнему виду и поведению экранов](android-screens-behaviours.md)



# 1 Вступление <a name="1"></a>

Приветствую тебя, Android developer компании [Heads and Hands](http://handh.ru)! Надеюсь, ты 
внимательно ознакомишься с этими рекомендациями и будешь применять их на практике! Это поможет 
всем нам писать  единообразный код и быть счастливыми, когда нужно будет продолжать проект 
за кем-то другим. Стоит понимать, что пожелания и предложения приветствуются! Пиши их Игорю, или 
шли pull request.

# 2 Именование <a name="2"></a>

## 2.1 Файлы классов и пакеты <a name="2.1"></a>

Имена классов нужно писать в [UpperCamelCase](http://en.wikipedia.org/wiki/CamelCase).

Классы, которые наследуются от Android компонент нужно писать по следующему принципу:

Имя класса + Имя компонента Android. 

Например:  `SignInActivity`, `SignInFragment`, `ImageUploaderService`, `ChangePasswordDialog`.

Пакеты именуются в __lowercase__ без каких-либо разделителей, например: com.example.deepspace, 
но __не__ com.example.deepSpace или com.example.deep_space

## 2.2 Файлы ресурсов <a name="2.2"></a>

Все названия файлов ресурсов должны быть написаны в  __lowercase_underscore__.
Например: `view_flipper_transition_bottom_to_top.xml`, `activity_about.xml`, `ic_check_gender.png`.

## 2.3  Aйди элементов в layout файлах <a name="2.3"></a>

id элементов в layout файлах мы именуем в __CamelCase__. __Это единственный тип ресурсов, который мы 
так именуем__:

```xml
<ViewFlipper
   android:id="@+id/viewFlipper"
   android:layout_width="match_parent"
   android:layout_height="match_parent"/>
``` 

Для именования id у элементов используется следующий паттерн:
`@+id/textViewProfileFriendPhone`
где
* `textView` 	– тип элемента (__ОБЯЗАТЕЛЬНО__, причем не допускается сокращения в виде tv, btn, и тд. Если тип элемента не важен, то можно писать просто __viewSomething__.)
* `ProfileFriend` – имя экрана (параметр __не обязателен__. Удобно использовать когда есть, например карточка товара, которая выглядит по разному, но содержит абсолютно одинаковые элементы)
* `Phone`  – название элемента во ViewGroup (__обязательно__)

При этом `textViewProfileFriendPhone` – название переменной в коде. (либо `textViewPhone`). Допустимы оба варианта.
Данная строка описывает textView, в котором отображается телефон. При этом этот textView находится на экране профиля друга. 

## 2.4 Именование ресурсов <a name="2.4"></a>

Темы и стили в style.xml именуются в __CamelCase__.

Все остальные ресурсы (dimens, attrs, colors и тд.) именуются в __lowercase_underscore__.

## 2.5 Именование строк <a name="2.5"></a>
Все имена строк должны  начинаться с имени экрана, на котором они находятся и быть сгруппированы, а группа 
должна быть закомментирована. Пример: 

```xml
<!--БОКОВОЕ МЕНЮ-->
<string name="drawer_restaurants">Рестораны</string>
<string name="drawer_history">История заказов</string>
<string name="drawer_promo">Акции</string>
<string name="drawer_support">Связаться с нами</string>
<string name="drawer_address">Мой адрес</string>

<!--ЭКРАН СПИСКА РЕСТОРАНОВ-->
<string name="restaurants_empty_title">Ничего не найдено</string>
<string name="restaurants_empty_message">Ресторанов с заданными параметрами не обнаружено. Упростите параметры</string>
``` 

Общие строки на все приложение должны так же быть сгруппированы в файле.
Кнопки диалогов должны именоваться по такому принципу: action_cancel,  action_yes и тд. для удобства последующего переиспользования.

##2.6 Drawable файлы <a name="2.6"></a>

Как правило, все картинки уже именованы дизайнером в Zeplin и примерно 
соответствуют данным ниже рекомендациям.  Если что-то называется немного не по шаблону, не нужно 
тратить время на правильное переименование десятка файлов. 

__Важное замечание__: если встречается некая плашка/view в дизайне, или даже кнопка, которую нельзя 
сделать простым перекрашиванием обычной кнопки, что желательно сделать эту картинку 
стандартным __xml  drawable__  файлом.

Примеры - [раз](http://mgadarja.blogspot.ru/2011/03/android-xml-drawables.html), 
[два](http://startandroid.ru/ru/uroki/vse-uroki-spiskom/377-urok-162-grafika-drawable-shape-gradient.html). 
Это сэкономит нам размер апк. К 9-path нужно прибегать в крайних случаях. В 99% случаях можно обойтись без 9-path. 

Старайтесь избегать png. Т.е., если есть возможность использовать векторную графику, или 
отрисовать изображение в xml-drawable  - сделайте это! Вес приложения очень важен для нас.

Нужно придерживаться следующего принципа в именовании drawable файлов:

| Asset Type   | Prefix            |		Example               |
|--------------| ------------------|-----------------------------|
| Action bar   | `ab_`             | `ab_stacked.9.png`          |
| Toolbar       | `tb_`             | `tb_stacked.9.png`          |
| Button       | `btn_`	            | `btn_send_pressed.9.png`    |
| Dialog       | `dialog_`         | `dialog_top.9.png`          |
| Divider      | `divider_`        | `divider_horizontal.9.png`  |
| Icon         | `ic_`	            | `ic_star.png`               |
| Menu         | `menu_	`           | `menu_submenu_bg.9.png`     |
| Notification | `notification_`	| `notification_bg.9.png`     |
| Tabs         | `tab_`            | `tab_pressed.9.png`         |
| Фон чего-либо| `bg_`              | `bg_product.png`             |



Именование иконок: (taken from [Android iconography guidelines](http://developer.android.com/design/style/iconography.html)):

| Asset Type                      | Prefix             | Example                      |
| --------------------------------| ----------------   | ---------------------------- |
| Icons                           | `ic_`              | `ic_star.png`                |
| Launcher icons                  | `ic_launcher`      | `ic_launcher_calendar.png`   |
| Menu icons and Action Bar icons | `ic_menu`          | `ic_menu_archive.png`        |
| Status bar icons                | `ic_stat_notify`   | `ic_stat_notify_msg.png`     |
| Tab icons                       | `ic_tab`           | `ic_tab_recent.png`          |
| Dialog icons                    | `ic_dialog`        | `ic_dialog_info.png`         |



Именование selector states (состояний кнопки, например):

| State	       | Suffix          | Example                     |
|--------------|-----------------|-----------------------------|
| Normal       | `_normal`       | `btn_order_normal.9.png`    |
| Pressed      | `_pressed`      | `btn_order_pressed.9.png`   |
| Focused      | `_focused`      | `btn_order_focused.9.png`   |
| Disabled     | `_disabled`     | `btn_order_disabled.9.png`  |
| Selected     | `_selected`     | `btn_order_selected.9.png`  |


## 2.7 Layout файлы <a name="2.7"></a>

Layout  файлы должны именоваться по следующему принципу:

* item_ххх - наименование элементов списков. Если есть несколько экранов с одинаковыми внешне 
элементами, но разным содержимым (есть 5 экранов различных типов людей. три из них выглядят 
одинаково, а у двоих разные лейауты) то поступаем так:
* * item_people.xml (для 3 одинаковых экранов)
* * item_people_clever.xml (для экрана с умными людьми)
* * item_people_nice.xml (для экранов с хорошими людьми)
* fragment_xxx - лейаут фрагмента
* activity_xxx - лейаут активити
* dialog_xxx - лейаут диалога
* view_xxx - лейаут какой-либо вьюхи, которая инклудится в другие вьюхи. __Не нужно__ называть такие файлы
  layout_xxx. Допускается выносить контент экранов в лейауты __content_xxx__.
* header_xxx - хэдер списка (Довольно редкий случай, допускается именовать хэдер как item_xxxx).
* footer_xxx - футер списка. Аналогично header'у

## 2.8 Menu файлы <a name="2.8"></a>
Это файлы, которые описывают меню в тулбаре/экшон баре.
 
Пример правильного именования: Для UserActivity,  меню должно называться `activity_user.xml` или `user.xml`. 
Приставка `menu_` не обязательна, т.к. эти файлы уже лежат в папке `menu`.
В случае, если файл меню содержится на разных экранах и делает одно и тоже, то его 
следует называть: `search.xml`, `done.xml` и тд.

# 3 Code guidelines <a name="3"></a>

## 3.1 Общие рекомендации по стилю кода <a name="3.1"></a>

* __Обязательно__ ознакомься с https://source.android.com/source/code-style.html .

* Чтобы наш код не разносило автоформатированием по-разному, установи 
[файлик стиля кода](handhscheme.xml).
![](handh_scheme_file.jpg)

* Максимальная длина строки 130 символов. Убедись, что она у тебя выставлена:
![](line_length.jpg)

* Всегда автоформатируй код перед заливкой его в гит или просто во время работы.

* Замечание по if..else: наши статические анализаторы кода не пропустят код:
```java
if (true) doSomething();
```
Правильнее будет написать: 
```xml
if (true) {
    doSomething()
};
```

* Замечание: мы __не именуем__ переменные класса как `private int mPrivate`; т.е. приписывать букву `m` не нужно.

* Мы используем следующие правила для именование полей в классах:
   ```java
   public class MyClass {
       public static final int SOME_CONSTANT = 42; //константы капсом, расположены всегда наверху класса
       public int publicField;
       private static MyClass singleton;
       int packagePrivate;
       private int private;
       protected int protected;
   }
   ```

## 3.2 Annotations <a name="3.2"></a>
* Используй стандартные Java аннотации.
* Используй аннотации из support library, такие как @NonNull, @Nullable, аннотации указания типа ресурсов и тд. 
https://developer.android.com/studio/write/annotations.html
* Аннотации для полей нужно писать в одну строчку:
```java
@BindView(R.id.appBarLayout) AppBarLayout appBarLayout;
@Inject MainPresenter mainPresenter;
```
* Аннотации для классов нужно писать каждую на своей строчке
```java
@AnnotationA
@AnnotationB
public class MyAnnotatedClass { }
```
Это же правило справедливо для методов.

## 3.3 Порядок методов в классе <a name="3.3"></a>
В основном этот раздел описывает порядок методов в классах `Activity` и `Fragment`, для простых классов нужно 
просто исключить поля, которые не подходят.

1. Константы
2. Поля класса. Старайтесь группировать поля, которые относятся к одному логическому блоку и 
отделять блоки пустой строкой. Приветствуются комментарии.
3. Конструкторы.
4. Для создания активити всегда используйте метод __createStartIntent()__.
 
   В нем же в интент помещайте параметры, которые хотите передать в активити.

   __Флаги запуска__ интента в этом методе устанавливать __НЕЛЬЗЯ__.

   Данный метод можно переименовывать, чтобы более точно указать на характер создаваемой активити, 
если эта активити содержит в себе 2 и более разных поведений: `createSearchStartIntent()`, 
`createCatalogStartIntent` (оба метода запускают 1 активити, но с разными параметрами)
   ```java
   public static Intent createStartIntent(Context context, int param) {
       Intent intent = new Intent(context, MainActivity.class);
       intent.putExtra(EXTRA_CONST, param);
       return intent;
   }
   ```
   Далее в коде
    ```java
   startActivity(MainActivity.createStartIntent(context, intVariable));
   ```
   или 
   ```java
   Intent intent = MainActivity.createStartIntent(context, intVariable);
   intent.setFlags(FLAGS);
   startActivity(intent);
   ```

   Все тоже самое справедливо и для фрагментов, только метод у фрагментов должен называться __newInstance()__.

   __Создавать фрагменты и активити без этих методов НЕЛЬЗЯ__.

5. Методы жизненного цикла активити/фрагмента в правильном порядке
6. Public methods
7. Private methods
7. Override methods and callbacks (public or private) (кроме методов жизненного цикла)
8. MVP методы
9. Inner classes or interfaces

# 4 Общие рекомендации <a name="4"></a>

* Мы используем __Android Studio из стабильной ветки__. Beta и Canary билды в продакшене не допускаются для использования.
* Пиши комментарии. Они помогут ближнему твоему. Если сомневаешься, нужно ли тут писать комментарий,
 то открой этот участок кода через неделю и если моментально не сообразишь, что делает код - пиши 
 описание. 
Крайне желательно писать комментарии к каждому классу, который содержит логику. Особенно важно для 
активити 
и фрагментов.

   Если код содержит хоть какую-то сложную логику - задокументируй ее. Если написал костыль - задокументируй его, 
   напиши зачем так было сделано.
* Вот пример, на котором базируются ряд наших проектов: https://github.com/ribot/android-boilerplate .
Если будет скучно и одиноко, ознакомься с ним.
* Уходим от использования `ActionBar`. Т.е. вызывать `setSupportActionBar(toolbar)` больше не нужно! 
Возрадуемся, братья. Меню так же теперь делаем через тулбар. Т.е. `toolbar.inflateMenu(int resId)` и 
`toolbar.setOnMenuItemClickListener` наши новые друзья.
* Если в твоем приложении что-то меняется в зависимости от типа билда (дебаг/релиз, внутренний 
билд/билд для заказчика и тд) 
используй BuildConfig. 
Т.е. __ОБЯЗАТЕЛЬНО__ сделай так, чтобы тебе не пришлось ручками менять адрес сервера для разных сборок, 
или ключ карты, или что-то еще такое. Инструментарий позволяет. Если не знаешь как, есть сомнения - спроси у 
мейнтейнера своего проекта или у Игоря. Прямо сейчас в своем текущем проекте сделай так, чтобы 
избавить себя от изменения подобных вещей ручками.
* В файлах верстки (.xml) всем вьюхам через `tools:имя_атрибута` прописывайте значения. Картинкам 
устанавливайте 
`tools:background` и тд. Все это нужно, чтобы при открытии данной вьюхи в layout editor можно было 
составить 
представление о данной вью. 

  __Запрещается__ текстовым полям присваивать “временные” значения в верстке через `android:text=”Заголовок”`, 
  т.к. это ведет к факапам и багам.
* В списках (`RecyclerView`) у элементов `ViewHolder`, метод, который присваивает значения элементам интерфейса ячейки 
должен называться `bindXxxx(параметры)` или просто `bind(параметры)` и реализовываться внутри класса `ViewHolder`. 
Т.е. реализовывать биндинг данных в интерфейс непосредственно в методе `onBindViewHolder(RecyclerView.ViewHolder holder, 
int position)` __нельзя__.

# 5 Настройка билдов <a name="5"></a>

Даже если ты не пока что не являешься тем человеком, который настраивает проект, ты обязан прочитать этот пункт, чтобы 
понимать процессы.

## 5.1 Типы билдов и их настройка <a name="5.1"></a>

Мы работаем с четырьмя типами билдов:
1. debug - используют только разработчики.
   * ключ debug
   * обфускация отключена
   * суффикс у имени версии -debug
   * название файла app-debug.apk

2. internal - проверяют тестировщики и отправляются заказчику как промежуточные билды. Берутся из hockeyApp для тестировщиков и из отдельного hocckey для заказчика. Mapping файл сохраняется в TeamCity.
   * ключ debug
   * обфускация включена
   * собираются из develop ветки
   * суффикс у имени версии -internal
   * название файла app-internal.apk
   
3. beta - выкладываются в Beta Google Play автоматически при сборке. Можно скачать только оттуда.
Mapping файл сохраняется в TeamCity.
   * ключ release
   * обфускация включена
   * собираются из release ветки
   * суффикс у имени версии -betaX, где Х - кол-во коммитов в релиз ветке + 1. Т.е. минимальное название beta1
   * название файла app-beta.apk

4. release - выкладываются в Beta Google Play при мерже релиза в мастер. Можно скачать только оттуда. 
Mapping файл сохраняется в TeamCity.
   * ключ release
   * обфускация включена
   * собираются из master ветки
   * суффикс у имени версии отсутсвует
   * название файла app-release.apk

## 5.2 Общие положения по настройке билдов <a name="5.2"></a>

* __Обязательно__ сделай папку app/keystore  и положи `debug.keystore` в нее и настрой проект так, 
чтобы использовался именно этот кейстор. Так же положи туда релизный ключик (да, это не безопасно. 
Но это нам необходимо, чтобы не терять ключи). А вот пароль от этого ключа положи в файл 
`release_keystore.properties` (в корне проекта) , который __НЕ ЗАЛИВАЙ__ в гит.

  Содержимое файла `release_keystore.properties`:
  ```
  keystore = название.jks
  storePassword = пароль
  keyAlias = алиас
  keyPassword = пароль
  ```

   Пример конфигурации:
   ```
   //для подписки релизного билда
    File releaseSignFile = rootProject.file('release_keystore.properties')
    Properties releaseSignProperties
    if (releaseSignFile.exists()) {
        releaseSignProperties = new Properties()
        releaseSignProperties.load(new FileInputStream(releaseSignFile))
    }

    signingConfigs {
        release {
            storeFile file('keystore/' + releaseSignProperties['keystore'])
            storePassword releaseSignProperties['storePassword']
            keyAlias releaseSignProperties['keyAlias']
            keyPassword releaseSignProperties['keyPassword']
        }

        debug {
            storeFile file('keystore/debug.keystore')
            keyAlias 'androiddebugkey'
            storePassword 'android'
            keyPassword 'android'
        }
    }

    buildTypes {
        //билд для сторов
        release {
            signingConfig signingConfigs.release
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        //билд для беты в сторе. Именно этот билд отдается заказчику как промежуточный. Собирается из release ветки.
        beta {
            initWith release
        }
        //билд, которым пользуются только разработчики
        debug {
            signingConfig signingConfigs.debug
            minifyEnabled false            
            debuggable true
        }
        //билд, который тестят тестировщики в ходе разработки
        internal {
            initWith release
            signingConfig signingConfigs.debug
        }
    }
   ```

* Не устанавливай руками номер и имя версии билда. Используй для этого наш плагин: https://plugins.gradle.org/plugin/ru.handh.versionmaker
При этом versionName и versionCode из defaultConfig можно удалить 
* Все проекты, которые мы выпускаем должны быть обфусцированы.
* Если ты наткнулся на multidex, то не используй флейворы, т.к. ты потеряешь линт.
Вместо этого, в первой строчке app/build.gradle пропиши 
   ```
   //нужно для того, чтобы у нас для дебаг сборок с мультидексом билд собирался быстрее
   //Preferences -> Build,Execution,Deployment -> Compiler -> выставить -PdevMinSdk=21 в параметры запуска
   int minSdk = hasProperty('devMinSdk') ? devMinSdk.toInteger() : rootProject.ext.minSdkVersion
   ```
   ![](multidex.jpg)
   и выставляй минимальную версию сдк 
   ```
   defaultConfig {
              minSdkVersion minSdk
              ...
      }
   ```
* Чтобы билды, которые мы даем заказчику не содержали в себе Bugsee ознакомься с  https://github.com/Heads-and-Hands/AllowBugSee-android:

## 5.3 Автоматическая выкладка билдов в Google Play <a name="5.3"></a>

//TODO НАПИСАТЬ

# 6 GIT <a name="6"></a>

Гит - друг наш. Можешь пользоваться консолью, как пацан. Или Source Tree, как чмо позорное 
(автор пользуется source tree). 
* Разработка ведется по git-flow.  Что это значит?

   Основной является ветка __develop__. В ней всегда содержится самая актуальная, __РАБОЧАЯ__ версия 
   проекта. Тестировщики забирают билды на тесты именно отсюда.
   
   Каждый раз, когда начинаешь делать новую фичу, отводи __feature__ ветку, называй ее в соответствии с 
   номером таска из редмайна, например `feature/1865_spash_screen`. Когда делаешь мерж коммит данной 
   ветки в девелоп, в описании коммита указывай номер такска и описание того, что было сделано, например 
   `“1865: сделан сплеш скрин”` именно в таком формате.
   
   Когда настает пора выпускать релиз, создавай __release__ ветку от develop и называй ее номером версии. 
    Например, __1.1.2__. О номерах версий будет ниже. В релиз ветке не реализуются новые фичи, только 
    правятся баги перед финальной выкладкой в стор. Помни, что пуши в релиз ветку автоматически 
    отправляют билд в бету гугл плея. Когда все баги исправлены, мержи релизную ветку в мастер и 
    тегируй названием версии. Именно этот тэг будет использоваться как версия, которую будут видеть люди в 
     гугл плее. 
   
   Ветка __master__ содержит релизные билды, которые выложены в стор. Не забывай тегировать 
   такие пуши текущей версией приложения. Mapping файлы хранятся в TeamCity.
      

* Старайся избегать коммитов, в которых залито исправление факапа. Т.е. лучше объедини коммиты, 
чем запуш еще 1 коммит с исправлением одной строчки.

* Помни, ушел домой, запуш изменения на сервер! Потому что утром может быть пожар,  а твои изменения 
только у тебя на компе. Так же не забывай удалять feature ветки с удаленного репозитория, чтобы все 
было чистенько.

* Для удобства разработки у нас настроены скрипты, [ознакомься](https://www.notion.so/7/commit-Redmine-82c5c31f487047f591718090ba4921b1). 

# 7 Именование версий <a name="7"></a>
Предлагается следующее именование версий:

__х.у.z (1.2.156)__
* x - основной номер, меняется редко.
* у - паки фич
* z - фиксы

* х повышается, когда приходят кардинальные или очень большие изменения в проект.
* y  повышается, когда внедряем новые фичи или паки фич. Например, прикрутили платежку.
* z повышается, когда что-то поправили

В самый первый релиз бета тестирования на ГП должно уходить 1.0.0.

Вся нумерация касается только релизных билдов. Во внутренних нуждах за вас все будет делать код выше.

# 8 Раздел для Kotlin <a name="8"></a>
В данный момент (14 августа 2017) у нас идет 1 тестовый проект на котлине, на котором мы собираем подводные камни. Дальше будет принято решение о повсеместном использовании котлина.

# 9 Актуальные библиотеки на 24 апреля 2017 года <a name="9"></a>
* [Retrofit2](http://square.github.io/retrofit/) для сети - must have
* [ButterKnife](http://jakewharton.github.io/butterknife/) для биндинга элементов интерфейса. 
Внимательно читай доку, если пользуешься фрагментами, не забывай делать unbind.
* RxJava и RxAndroid - в данный момент используем в основном для асинхронности сети и доступа к БД.
* [Glide](https://github.com/bumptech/glide)) / Picasso для загрузки картинок. Glide в приоритете из 
за лучшего потребления памяти и более широких возможностей (умеет воспроизводить gif и вообще 
гугл форсит)
* [Dagger2](http://google.github.io/dagger/) для внедрения зависимостей
* [Logging Interceptor](https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor) чтобы 
отслеживать запросы прям в логкете.
* [Chuck](https://github.com/jgilfelt/chuck) для просмотра логов сети прямо на устройстве. Очень удобно 
для тестеров. Считаю, что маст хэв
* [Logging Interceptor](https://github.com/ihsanbal/LoggingInterceptor) - более крутой логгер сети для логкэта.
Считаю его более приоритетным, чем первый. Маст хэв
* [StorIo](https://github.com/pushtorefresh/storio), [SqlBrite](https://github.com/square/sqlbrite),
[Realm](https://realm.io/) - прошли боевое крещение для работы с базой. Выбирай библиотеку для базы в 
зависимости от нужд проекта, а не от “ай, а вот такую я еще не юзал, надо попробовать”
* [Transitionseverywhere](https://github.com/andkulikov/Transitions-Everywhere) - хороший бекпорт 
транзишонов. Проверено, работает.
* [Timber](https://github.com/JakeWharton/timber) - для логирования, must have
* [Android Debug Database](https://github.com/amitshekhariitbhu/Android-Debug-Database) - отличная библиотека для просмотра базы и 
шаред преференсов в браузере. Tсли в проекте есть sqlite база - маст хэв.
* Gson - для парсинга json, он быстрее и меньше методов занимает
* [Retrolambda](https://github.com/evant/gradle-retrolambda) - лямбды в андроид! Маст хэв штука


# 10 Задачи “Просто верстаем, пока нет API” <a name="10"></a>

Если на вас стоит задача во верстке, то приступить к ее выполнению вы можете только в случае 
соблюдения следующих условий:
1. Дизайн отрисован и утвержден
2. Есть спецификация по API, утвержденная с заказчиком в письменном виде. 
Если одно из условий не выполняется, а менеджер давит, то необходимо сообщить об этом Игорю для 
решения сложившийся ситуации.

В рамках таких задач вы должны делать полноценное приложение, которое отличается от обычного лишь тем, 
что все ваши запросы к АПИ заменяются заглушками. Т.е. все модели, все ответы и запросы вы 
должны описать и сделать. И в момент, когда появляется API вы просто убираете заглушки, и в идеальном 
случае все начинает работать. На деле такая ситуация редко будет и все-таки придется что-то допиливать. 

Если вы сделали задачи по верстке по принципу “накидал вью, вбил туда хардкодом тексты и картинки”, 
то задача считается невыполненной.

# 12 Рекомендации по архитектуре <a name="12"></a>
В наших проектах используется MVP архитектура. Основой для архитектуры служит проект https://github.com/ribot/android-boilerplate
Обязательно прочитай описание этого проекта на гитхабе, особенно обрати внимание на
[этот](https://github.com/ribot/android-boilerplate#how-to-implement-a-new-screen-following-mvp)
раздел.

Неочевидные моменты, о которых мы договорились:
* В фрагментах detach и attach презентеров делать в методах onCreateView и 
onDestroyView
* Презентер не должен ничего знать о Android SDK. Т.е. внутри презентера следует 
избегать использовать классы,
связанные с Android. Тоже самое касается ресурсов - в презентере нельзя обращаться к 
ним, например к R.string и R.drawable и тд.
* Презентер не должен хранить объекты с данными
* Активити не должно вызывать методы MvpView. Все такие пробросы делать через презентер
* Активити должно стартовать другие активити только через метод MvpView
* Помни о правильном создании интентов для активити (пнукт 3.3)










